import Ajv from 'ajv';
import { evaluate as evaluateCEL } from 'cel-js';

/**
 * Type definitions for the templating engine
 */

interface CompileContext {
  variables: Map<string, any>;
  schema?: any;
  parentPath: string;
}

interface CompileOptions {
  context?: Record<string, any>;
}

/**
 * Main compile function - entry point for the templating engine
 */
export function compile(record: any, options?: CompileOptions): any {
  const context: CompileContext = {
    variables: new Map(Object.entries(options?.context || {})),
    parentPath: '$',
  };

  return compileValue(record, context);
}

/**
 * Core recursive compiler function
 */
function compileValue(value: any, context: CompileContext): any {
  if (value === null || value === undefined) {
    return value;
  }

  if (Array.isArray(value)) {
    return compileArray(value, context);
  }

  if (typeof value === 'object' && value !== null) {
    return compileObject(value, context);
  }

  // Strings and other primitives pass through — ${{ }} is runtime-only syntax
  return value;
}

/**
 * Compile array values
 */
function compileArray(arr: any[], context: CompileContext): any {
  const result: any[] = [];

  for (const item of arr) {
    if (isDirectiveObject(item) && '$for' in item) {
      // Handle $for directive
      const forResults = handleForDirective(item, context, 'array');
      if (Array.isArray(forResults)) {
        result.push(...forResults);
      } else {
        result.push(forResults);
      }
    } else {
      result.push(compileValue(item, context));
    }
  }

  return result;
}

/**
 * Compile object with directive processing
 */
function compileObject(obj: any, parentContext: CompileContext): any {
  // Step 1: Process $schema first to validate parent scope data
  let schema: any = undefined;
  if ('$schema' in obj) {
    schema = obj['$schema'];
    // Validate parent scope variables against schema
    validateAgainstSchema(
      parentContext.variables,
      schema,
      parentContext.parentPath,
    );
  }

  // Create child context with updated schema
  const context: CompileContext = {
    variables: new Map(parentContext.variables),
    schema: schema,
    parentPath: parentContext.parentPath,
  };

  // Step 2: Process $let - add variables to context
  if ('$let' in obj) {
    const letVars = obj['$let'];
    for (const [key, expr] of Object.entries(letVars as Record<string, any>)) {
      try {
        const value = evaluateExpression(expr, context);
        context.variables.set(key, value);
      } catch (error) {
        throw new Error(
          `Error evaluating $let variable "${key}" at "${context.parentPath}": ${error}`,
        );
      }
    }
  }

  // Step 3: Process $assert
  if ('$assert' in obj) {
    const assertion = obj['$assert'];
    try {
      const result = evaluateCEL(
        assertion,
        Object.fromEntries(context.variables),
      );
      if (!result) {
        const msg = obj['$msg'] || `Assertion failed: ${assertion}`;
        throw new Error(msg);
      }
    } catch (error) {
      throw new Error(`Assertion failed at "${context.parentPath}": ${error}`);
    }
  }

  // Step 4: Process $if/$then/$else
  if ('$if' in obj) {
    const hasDataKeys = Object.keys(obj).some((key) => !key.startsWith('$'));
    if (hasDataKeys) {
      const baseResult: Record<string, any> = {};
      for (const [key, value] of Object.entries(obj)) {
        if (key.startsWith('$')) {
          continue;
        }
        const childPath = `${context.parentPath}.${key}`;
        const childContext: CompileContext = {
          ...context,
          parentPath: childPath,
        };
        baseResult[key] = compileValue(value, childContext);
      }

      const conditionalResult = handleIfDirective(obj, context);
      if (
        conditionalResult &&
        typeof conditionalResult === 'object' &&
        !Array.isArray(conditionalResult)
      ) {
        return { ...baseResult, ...conditionalResult };
      }

      if (conditionalResult === undefined) {
        return baseResult;
      }

      return conditionalResult;
    }

    return handleIfDirective(obj, context);
  }

  // Step 5: Process $for/$do
  if ('$for' in obj) {
    return handleForDirective(obj, context, 'object');
  }

  // Step 6: Process $eval — explicit compile-time evaluation
  if ('$eval' in obj) {
    const evalValue = obj['$eval'];
    if (typeof evalValue === 'string') {
      return compileString(evalValue, context);
    }
    return evalValue;
  }

  // Step 6b: Process $key/$value (used in $for/$do for dynamic keys)
  if ('$key' in obj && '$value' in obj) {
    const keyContext: CompileContext = { ...context, parentPath: `${context.parentPath}.$key` };
    const valueContext: CompileContext = { ...context, parentPath: `${context.parentPath}.$value` };
    return {
      $key: compileValue(obj['$key'], keyContext),
      $value: compileValue(obj['$value'], valueContext),
    };
  }

  // Step 7: Process $include/$with
  if ('$include' in obj) {
    // Include requires file system access - stub for now
    throw new Error('$include directive not yet implemented');
  }

  // Step 7: Compile regular keys
  const result: Record<string, any> = {};
  for (const [key, value] of Object.entries(obj)) {
    // Skip directive keys
    if (key.startsWith('$')) {
      continue;
    }

    const renderedKey = key;
    const childPath = `${context.parentPath}.${renderedKey}`;
    const childContext: CompileContext = {
      ...context,
      parentPath: childPath,
    };

    result[renderedKey] = compileValue(value, childContext);
  }

  return result;
}

/**
 * Compile string with interpolation support
 */
function compileString(str: string, context: CompileContext): any {
  const matches = Array.from(str.matchAll(/\$\{\{([^}]+)\}\}/g));

  if (matches.length === 0) {
    return str;
  }

  // If the entire string is a single interpolation, return the value type
  if (matches.length === 1 && matches[0][0] === str) {
    const expr = matches[0][1] as string;
    try {
      const value = evaluateCEL(expr, Object.fromEntries(context.variables));
      if (value === undefined) {
        throw new Error(`Undefined variable "${expr}"`);
      }
      return value;
    } catch (error) {
      throw new Error(
        `Error evaluating interpolation "${expr}" at "${context.parentPath}": ${error}`,
      );
    }
  }

  // Otherwise, concatenate all parts as strings
  let result = str;
  for (const match of matches) {
    const expr = match[1] as string;
    try {
      const value = evaluateCEL(expr, Object.fromEntries(context.variables));
      if (value === undefined) {
        throw new Error(`Undefined variable "${expr}"`);
      }
      result = result.replace(match[0], String(value));
    } catch (error) {
      throw new Error(
        `Error evaluating interpolation "${expr}" at "${context.parentPath}": ${error}`,
      );
    }
  }

  return result;
}

/**
 * Handle $if/$then/$else directive
 */
function handleIfDirective(obj: any, context: CompileContext): any {
  const condition = obj['$if'];

  try {
    const result = evaluateCEL(
      condition,
      Object.fromEntries(context.variables),
    );

    if (result && '$then' in obj) {
      return compileValue(obj['$then'], context);
    } else if (!result && '$else' in obj) {
      return compileValue(obj['$else'], context);
    } else if (result) {
      // If condition is true but no $then, return undefined
      return undefined;
    }
  } catch (error) {
    throw new Error(
      `Error evaluating $if condition "${condition}" at "${context.parentPath}": ${error}`,
    );
  }

  return undefined;
}

/**
 * Handle $for/$do directive
 */
function handleForDirective(
  obj: any,
  context: CompileContext,
  mode: 'array' | 'object',
): any {
  const forExpr = obj['$for'];
  const doTemplate = obj['$do'];

  if (!doTemplate) {
    throw new Error(`Missing $do in $for directive at "${context.parentPath}"`);
  }

  // Parse the for expression: "item in list" or "key, val in map" or "i in range(5)"
  const forMatch = forExpr.match(/^(.+?)\s+in\s+(.+)$/);
  if (!forMatch) {
    throw new Error(
      `Invalid $for syntax "${forExpr}" at "${context.parentPath}". Expected "item in collection" or "key, val in map"`,
    );
  }

  const iteratorPart = forMatch[1].trim();
  const collectionExpr = forMatch[2].trim();

  try {
    const collection = evaluateCEL(
      collectionExpr,
      Object.fromEntries(context.variables),
    );
    const results: any[] = [];

    if (Array.isArray(collection)) {
      // Handle list iteration
      const itemName = iteratorPart;
      for (const item of collection) {
        const itemContext: CompileContext = {
          ...context,
          variables: new Map(context.variables),
        };
        itemContext.variables.set(itemName, item);
        results.push(compileValue(doTemplate, itemContext));
      }
    } else if (typeof collection === 'object' && collection !== null) {
      // Handle map iteration
      const [keyName, valName] = iteratorPart
        .split(',')
        .map((s: string) => s.trim());
      if (!valName) {
        throw new Error(
          `Invalid map iterator "${iteratorPart}" at "${context.parentPath}". Expected "key, val"`,
        );
      }

      for (const [key, val] of Object.entries(collection)) {
        const itemContext: CompileContext = {
          ...context,
          variables: new Map(context.variables),
        };
        itemContext.variables.set(keyName, key);
        itemContext.variables.set(valName, val);
        results.push(compileValue(doTemplate, itemContext));
      }
    } else {
      throw new Error(
        `Collection in $for must be array or object, got ${typeof collection} at "${context.parentPath}"`,
      );
    }

    if (mode === 'array') {
      return results;
    }

    const merged: Record<string, any> = {};
    for (const item of results) {
      if (item && typeof item === 'object' && '$key' in item && '$value' in item) {
        merged[item['$key']] = item['$value'];
      } else if (typeof item !== 'object' || item === null || Array.isArray(item)) {
        throw new Error(
          `Object-mode $for must produce objects at "${context.parentPath}"`,
        );
      } else {
        Object.assign(merged, item);
      }
    }
    return merged;
  } catch (error) {
    throw new Error(
      `Error in $for directive at "${context.parentPath}": ${error}`,
    );
  }
}

/**
 * Validate object against schema
 */
function validateAgainstSchema(
  variables: Map<string, any>,
  schema: any,
  path: string,
): void {
  const ajv = new Ajv();

  // Build a JSON schema for validation
  const jsonSchema: any = {
    type: 'object',
    properties: {},
  };

  for (const [key, constraint] of Object.entries(
    schema as Record<string, any>,
  )) {
    jsonSchema.properties[key] = normalizeSchemaConstraint(constraint);
  }

  // Create validator
  const validate = ajv.compile(jsonSchema);

  // Convert Map to object for validation
  const data = Object.fromEntries(variables);

  if (!validate(data)) {
    const errors = validate.errors
      ?.map((e) => `${e.instancePath || '/'}: ${e.message}`)
      .join('; ');
    throw new Error(`Schema validation failed at "${path}": ${errors}`);
  }
}

/**
 * Normalize a single schema constraint to JSON Schema format
 */
function normalizeSchemaConstraint(constraint: any): any {
  if (typeof constraint === 'string') {
    // Simple type string like 'string', 'number', etc.
    return { type: constraint };
  }

  if (typeof constraint === 'object' && constraint !== null) {
    // Already an object, assume it's JSON Schema
    return constraint;
  }

  return {};
}

/**
 * Check if an object contains directive keys
 */
function isDirectiveObject(obj: any): boolean {
  if (typeof obj !== 'object' || obj === null) {
    return false;
  }

  return Object.keys(obj).some((key) => key.startsWith('$'));
}

function evaluateExpression(expr: any, context: CompileContext): any {
  // Handle $eval objects (e.g. from $let values)
  if (typeof expr === 'object' && expr !== null && '$eval' in expr) {
    const evalValue = expr['$eval'];
    if (typeof evalValue === 'string') {
      return compileString(evalValue, context);
    }
    return evalValue;
  }

  if (typeof expr !== 'string') {
    return expr;
  }

  const trimmed = expr.trim();
  const isSingleQuoted =
    trimmed.startsWith("'") && trimmed.endsWith("'");
  const isDoubleQuoted =
    trimmed.startsWith('"') && trimmed.endsWith('"');
  const isQuoted = isSingleQuoted || isDoubleQuoted;

  if (isQuoted) {
    return trimmed.slice(1, -1);
  }

  return evaluateCEL(expr, Object.fromEntries(context.variables));
}


/**
 * Export types
 */
export { CompileContext, CompileOptions };
