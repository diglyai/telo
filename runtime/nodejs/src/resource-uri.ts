/**
 * ResourceURI: Parses and builds standard URIs for resources
 *
 * Format: scheme://host/path#kind.name[/kind.child/kind.child/...]
 * Examples:
 *   file:///path/to/file.yaml#Http.Server.Example
 *   http://localhost/template/ApiServer#Http.Server/api-us-east
 *   https://example.com/resources.yaml#Data.Type.User
 */
export class ResourceURI {
  readonly scheme: string;
  readonly host: string;
  readonly path: string;
  readonly fragment: string; // kind.name/kind.child/...

  private constructor(
    scheme: string,
    host: string,
    path: string,
    fragment: string,
  ) {
    this.scheme = scheme;
    this.host = host;
    this.path = path;
    this.fragment = fragment;
  }

  /**
   * Parse a URI string into components
   * Format: scheme://host/path#fragment
   */
  static parse(uri: string): ResourceURI {
    const schemeMatch = uri.match(/^([a-z][a-z0-9+.-]*):\/\//);
    if (!schemeMatch) {
      throw new Error(
        `Invalid URI format: ${uri}. Expected "scheme://host/path#fragment"`,
      );
    }

    const scheme = schemeMatch[1];
    const rest = uri.slice(schemeMatch[0].length);

    // Split host/path from fragment
    const hashIndex = rest.indexOf('#');
    if (hashIndex === -1) {
      throw new Error(`Invalid URI format: ${uri}. Missing fragment after "#"`);
    }

    const hostPath = rest.slice(0, hashIndex);
    const fragment = rest.slice(hashIndex + 1);

    if (!fragment) {
      throw new Error(`Invalid URI format: ${uri}. Fragment cannot be empty`);
    }

    // Split host from path
    const pathIndex = hostPath.indexOf('/');
    let host: string;
    let path: string;

    if (pathIndex === -1) {
      host = hostPath;
      path = '';
    } else {
      host = hostPath.slice(0, pathIndex);
      path = hostPath.slice(pathIndex);
    }

    if (!host) {
      throw new Error(`Invalid URI format: ${uri}. Host cannot be empty`);
    }

    return new ResourceURI(scheme, host, path, fragment);
  }

  /**
   * Build a file:// URI from an absolute file path and kind.name
   */
  static fromFile(
    absolutePath: string,
    kind: string,
    name: string,
  ): ResourceURI {
    const normalizedPath = absolutePath.replace(/\\/g, '/');
    const fragment = `${kind}.${name}`;
    return new ResourceURI('file', 'localhost', normalizedPath, fragment);
  }

  /**
   * Build a template URI from template definition name and kind.name
   * Used for resources generated by template expansion
   */
  static fromTemplate(
    templateDefinitionName: string,
    kind: string,
    resourceId: string,
  ): ResourceURI {
    const path = `/template/${templateDefinitionName}`;
    const fragment = `${kind}.${resourceId}`;
    return new ResourceURI('http', 'localhost', path, fragment);
  }

  /**
   * Create a child URI by appending kind.name to the fragment path
   * Used when a template generates child resources
   */
  withChild(kind: string, name: string): ResourceURI {
    const newFragment = `${this.fragment}/${kind}.${name}`;
    return new ResourceURI(this.scheme, this.host, this.path, newFragment);
  }

  /**
   * Get the full URI as a string
   */
  toString(): string {
    return `${this.scheme}://${this.host}${this.path}#${this.fragment}`;
  }

  /**
   * Get just the resource identifier part (kind.name)
   */
  getResourceId(): string {
    const parts = this.fragment.split('/');
    return parts[parts.length - 1];
  }

  /**
   * Get the kind and name from the last fragment component
   */
  getResourceKindName(): { kind: string; name: string } {
    const resourceId = this.getResourceId();
    const lastDot = resourceId.lastIndexOf('.');
    if (lastDot === -1) {
      throw new Error(`Invalid resource identifier in URI: ${this.toString()}`);
    }
    return {
      kind: resourceId.slice(0, lastDot),
      name: resourceId.slice(lastDot + 1),
    };
  }

  /**
   * Get the full fragment path as array of kind.name pairs
   */
  getFragmentPath(): string[] {
    return this.fragment.split('/');
  }

  /**
   * Check if this URI is from a file source
   */
  isFileSource(): boolean {
    return this.scheme === 'file';
  }

  /**
   * Check if this URI is from a template source
   */
  isTemplateSource(): boolean {
    return this.scheme === 'http' && this.path.startsWith('/template/');
  }

  /**
   * Check if this URI represents a generated/nested resource (has multiple fragment components)
   */
  isNested(): boolean {
    return this.fragment.includes('/');
  }

  /**
   * Get the depth of nesting (number of / in fragment)
   */
  getDepth(): number {
    return this.fragment.split('/').length - 1;
  }

  /**
   * Get the parent URI by removing the last fragment component
   * Returns undefined if already at root level
   */
  getParent(): ResourceURI | undefined {
    const parts = this.fragment.split('/');
    if (parts.length === 1) {
      return undefined;
    }
    const parentFragment = parts.slice(0, -1).join('/');
    return new ResourceURI(this.scheme, this.host, this.path, parentFragment);
  }

  /**
   * Get template name if this is a template-generated resource
   */
  getTemplateName(): string | undefined {
    if (!this.isTemplateSource()) {
      return undefined;
    }
    const match = this.path.match(/^\/template\/(.+)$/);
    return match ? match[1] : undefined;
  }
}
